<!DOCTYPE html>
<html manifest="main.appcache">
<head>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/backbone.js/1.2.0/backbone-min.js"></script>
    <style>
    .response-text {
        display: -webkit-box;
        display: -moz-flex;
        display: -ms-flexbox;
        display: flex;
    }

    .response-text::before,
    .response-overflow,
    .show-more {
        margin: auto 0;
    }

    .has_user_response .response-text::before {
        margin-right: 0.25em;
        content: 'Response:';
    }

    .show-more::after {
        content: 'more';
    }

    .response-overflow {
        width: calc(50% - 4em);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }
    </style>
</head>
<body>
    <ul class="todos">
    </ul>
    <script>
        var sampleFormData, EntryModel, EntryView, EntriesCollection, EntriesView, v;

        var WLApp = {
            config: {
                enableTwoWayText: true,
                maxResponseCharLength: 35
            },
        };

        $(document).ready(function () {

        sampleFormData = function () {
            return JSON.parse('{"id":"' + (Math.floor( 1 + Math.random()*800) ) + '","sync_id":"aGA_1431760486","user_id":null,"has_profile":false,"name":"Duty","size":"2","phone":"555-555-5555","past_visits":0,"hasPhone":false,"ping_count":0,"all_arrived":1,"notes":"Notes that go over here should","status":"queued","status_code":0,"status_color":null,"quoted_time":"120","table_no":null,"created_at_gmt":"2015-05-16 07:15:29","created_at_ts":1431760529,"updated_at_ts":1431760529,"ping1_at_ts":null,"ping2_at_ts":null,"ping3_at_ts":null,"completed_at_gmt":null,"completed_at_ts":null,"call_ahead_type":null,"checkedin_at":null,"call_ahead_checkedin_at":null,"res_type":null,"time_slot":0,"userResponse":"","waitlist_preseat_ids":null,"waitlist_preseat_names":null,"is_web":"0","type":"wait","predicted_secs":0,"predicted_ori_secs":0,"res_id":"923","version":"btbuild","since":1431760609,"lastSeqNo":894,"deviceId":"2_HSSStdyuGS","current_time":1431760715,"get_updates":true}');
        }

        /**
         * Model for a waitlist entry
         */
        EntryModel = Backbone.Model.extend({

            /**
             * default values
             * returns a function so that the default object is not shared among the all the instances
             */
            defaults: function () {
                return {
                    response: ''
                };
            },


            /**
             * run first
             * add any filters here or set up event listeners
             * @param Object attributes for this entry
             */
            initialize: function (attributes) {
                // error checking
                if (attributes.id === null){
                    // Logger.add('warn', 'Missing id in form data');
                    console.warn('Missing id in form data');
                }

                this._changeCancelToNoShow();

                if (this.get('completed_at_ts') === null) {
                    this._updateWaitingTime();
                }
                else {
                    this._updateWaitedTime();
                }

                // listen for any changes to the data
                this.on('change:status', this._onStatus, this);
                this.on('change:userResponse', this._processResponse, this);
                this.on('change:checkedin_at', this._updateWaitingTime, this);
            },

            /**
             * Hook for when status of the model changes
             */
            _onStatus: function () {
                this._changeCancelToNoShow();

                // update completed timestamp if we just moved to history list
                if ( /seat|noshow/i.test(this.get('status')) && ( this.get('completed_at_ts') === null || this._isSeatedFromNoShow() ) ) {
                    //this.set('completed_at_ts', adjustedNow);
                    this.set('completed_at_ts', Math.floor($.now() / 1000));
                }

                // we moved from history list back to current list
                if ( /queued|notify/i.test(this.get('status')) && this.get('completed_at_ts') !== null ) {
                    this.set('completed_at_ts', null);
                }

                // move queues
                console.log(this.queues);
            },

            /**
             * Process user/error response
             * @return EntryModel this
             */
            _processResponse: function () {
                var response = this.get('userResponse'),
                    hasResponse = this.get('completed_at_ts') === null && response !== null && response.length > 0,
                    isError = response.match(/^Error:/),
                    isUserResponse = WLApp.config.enableTwoWayText && this.get('status') !== 'usercancel';

                if ( hasResponse && ( isError || isUserResponse ) ) {
                    if (isError) {
                        this.set({ response: response, responseType: 'error' });
                    }
                    else if (isUserResponse) {
                        this.set({ response: response, responseType: 'user' });
                    }
                }
                else {
                    this.set({ response: null, responseType: null });
                }
            },

            /**
             * Set it to noshow if status is cancel
             * @return EntryModel this
             */
            _changeCancelToNoShow: function () {
                if (this.get('status') === 'cancel') {
                    this.set({ status: 'noshow' }, { silent: true }); // set to silent because the status just changed
                }

                return this;
            },

            /**
             * Calculate how long the party has been waiting for
             * @return EntryModel this
             */
            _updateWaitingTime: function () {
                // this.minWaiting = Math.round( adjustedNow - parseInt(this.get('created_at_ts'), 10) / 60),
                // this.minWaitingFormatted = WLApp.Util.min_to_human(this.minWaiting);
                this.set({
                    minWaiting: Math.round( ( Math.floor($.now()/1000) - this.get('created_at_ts') ) / 60),
                    minWaitingFormatted: this.minWaiting // this should be humanized
                });

                if (this._isCheckedIn()) {
                    this._updateMinutesInStore();
                }

                return this;
            },

            /**
             * Calculate how long the party waited
             * @return EntryModel this
             */
            _updateWaitedTime: function () {
                // this.minWaited = Math.round( this.get('completed_at_ts') - parseInt(this.get('created_at_ts'), 10) / 60),
                // this.minWaitedFormatted = WLApp.Util.min_to_human(this.minWaited);

                return this.set({
                    minWaited: Math.round( ( this.get('completed_at_ts') - parseInt(this.get('created_at_ts'), 10) ) / 60),
                    minWaitingFormatted: this.minWaited // this should be humanized
                });
            },

            /**
             * Calculate how long the party has been waiting at the venue once checked in
             * This will also be called upon check in
             * @return EntryModel this
             */
            _updateMinutesInStore: function () {
                var adjustedNow = Math.floor($.now()/1000), // use global adjustedNow
                    checkedInAt = this.get('checkedin_at'),
                    checkinDifference = (adjustedNow - checkedInAt),
                    minutesInStore =  checkinDifference < 0 ? 0 : checkinDifference / 60;

                return this.set({
                    // minutesInStoreLong = WLApp.Util.min_to_human(Math.round(minutesInStore)),
                    // minutesInStoreShort = Util.timeSince(checkedin_at, adjustedNow);
                    minutesInStoreLong: Math.round(minutesInStore),
                    minutesInStoreShort: Math.round(minutesInStore) 
                });

                //$item.find(".minutes-instore .minutes").text(minutesInStoreLong);
                //$item.find(".minutes-instore .short").text(
            },

            /**
             * Check if we are seating an entry from no-show status
             * @return bool
             */
            _isSeatedFromNoShow: function () {
                return this.previousAttributes().status === 'noshow' && this.get('status') === 'seat';
            },

            /**
             * Check if entry is checked in
             * @return bool
             */
            _isCheckedIn: function () {
                return this.get('checkedin_at') !== null && this.get('checkedin_at') > 0;
            },

        });

        /**
         * View for a single entry
         */
        EntryView = Backbone.View.extend({
            tagName: 'li',

            template: _.template(document.getElementById('entry-tpl').innerHTML),

            className: 'entry', // initial only, access className at: this.el.className

            initialize: function (options) {
                this.render();
                this.model.bind('change:userResponse', this._onUserResponse, this);
                this.model.bind('change', this.render, this);
            },

            render: function () {
                var waitlistContainerEl = this.el.querySelector('.waitlist_container'),
                    isRendered = waitlistContainerEl !== null,
                    content = this.template(_.extend(this.model.toJSON(), { isRendered: isRendered }));

                if (isRendered) {
                    waitlistContainerEl.innerHTML = content;
                }
                else {
                    this.el.innerHTML = content;
                }

                return this;
            },

            /**
             * Process user response when there is one
             * @return EntryView this
             */
            _onUserResponse: function (model) {
                var responseType = model.get('responseType'),
                    classList = this.el.querySelector('.waitlist_container').classList;

                classList.toggle('has_user_response', responseType === 'user');
                classList.toggle('has_error_response', responseType === 'error');
            },

        });

        /**
         * A collection of entries
         */
        EntriesCollection = Backbone.Collection.extend({
            model: EntryModel,
        });

        /**
         * View for the entries collection
         */
        EntriesView = Backbone.View.extend({

            /**
             * Constructor
             * make sure to specify this.el which we'll be appending to
             */
            initialize: function (options) {
                this.queues = {
                    current: [],
                    wait: [],
                    res: [],
                    sat: []
                },

                this.collection.each(this._addToProperQueue, this);

                // listen to model changes
                this.collection.on('change:status', this._addToProperQueue, this);
                this.render();
            },

            events: {
                'click .show-more': '_showMore',
            },

            /**
             * Refreshes which entries to show
             */
            render: function () {
                var fragment = document.createDocumentFragment();
                _(this.queues.current).each(function (entryView) {
                    fragment.appendChild(entryView.el);
                });
                this.el.appendChild(fragment);

                return this;
            },

            /**
             * Check which queue the entry belongs to then
             * add a view to that queue
             * @param EntryModel entry that needs to be queued
             * @return EntriesView this
             */
            _addToProperQueue: function (entry) {
                console.log('addToProperQueue');
                // queued
                if (entry.get('completed_at_ts') === null && !!! entry.get('res_type')) {
                    this.queues.wait.push(new EntryView({ model: entry }));
                }
                else {
                    console.warn('Warning: this does not belong to any status queues');
                }

                return this;
            },

            /**
             * Toggle whether to show more of the response text or not
             * @param n.Event ev is the event that was triggered by the element
             * @return EntriesView this
             */
            _showMore: function (ev) {
                var responseContainerEl = ev.currentTarget.parentElement; // we use currentTarget, which the eventListener is bound to, instead of target
                responseContainerEl.classList.toggle('showing-more');

                return this;
            }

        });

        // Sample data
        var sampleCollection = new EntriesCollection([sampleFormData(), sampleFormData(), sampleFormData() ]),
            todosListEl = document.querySelector('.todos');

        v = new EntriesView({ collection: sampleCollection, el: todosListEl });

        // Show wait queue
        var waitQueue = v.queues.wait,
            waitEntriesToMove = waitQueue.splice(0,waitQueue.length); // this removes entryViews from wait Queue so that they can be moved elsewhere

        v.queues.current = v.queues.current.concat(waitEntriesToMove); // usually we'd first move all entries in the current queue back to where they belong
        v.render();

        // test the user/error response
        v.collection.first().set({ userResponse: 'This is an example user response that has no error but still exceeds the one line limit because it has over 35 maximum characters'})
        v.collection.at(1).set({ userResponse: 'Error: This is an example error that exceeds the one line limit because it has over 35 maximum characters'})
    });


</script>
    <script id="entry-tpl" type="text/template">
        <% if (! isRendered) { %>
            <div class="waitlist_container">
        <% } %>
            <span class="status-indicator"></span>
            <span class="indicators">
                <span class="party-size"><%= size %></span>
                <span class="time-big"></span>
                <span class="table-no"><%= table_no %></span>
            </span>
            <div class="buttons">
                <?php if ($enable_profiles === true): ?>
                    <a class="profile"></a>
                <?php endif; ?>
                <a class="notify"><span class="notify_number"></span></a>
                <a class="sat"></a>
                <a class="noshow"></a>
                <a class="moveback"></a>
            </div>
            <h1><%= name %></h1>
            <div class="waittime">
                <span class="is-web">online</span>
                <span class="minutes-quoted"></span> 
                <span class="minutes-waited">
                    <span class="hide_in_portrait minutes-waited-longform">waiting </span>
                    <span class="minutes">0</span>
                </span> 
                <span class="minutes-instore">
                    <span class="long">
                        (<span class="minutes"></span>&nbsp;instore)
                    </span>
                    <span class="short"></span>
                </span>
                <span class="wait-since-ping">(<span class="minutes minutes-since-ping">0</span>m)</span>
            </div>
            <p class="phone"><%= phone /* Util.format_phone(phone) */ %></p>
            <p class="notes"><%= notes %></p>
            <p class="response-text">
                <% if (response.length > WLApp.config.maxResponseCharLength) { %>
                    <span class="response-overflow"><%= response %></span>
                    <a class="show-more"></a>
                <% } else { %>
                    <%= response %>
                <% } %>
            </p>
            <p class="web-msg">online res made on <span class="created-date"></span></p>
        <% if (! isRendered) { %>
            </div>
        <% } %>
    </script>
</body>
</html>
